<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#302b63">
  <title>Hit the Ethereum OS</title>
  <style>
    :root {
      --base-font-size: 16px;
      --container-width: 90%;
      --max-container-width: 900px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: 'Inter', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #2e3c4e, #302b63, #24243e);
      color: #e0e0e0;
      margin: 0;
      padding: 20px;
      overscroll-behavior: none;
    }

    @media screen and (max-width: 768px) {
      :root {
        --base-font-size: 14px;
        --container-width: 95%;
      }

      body {
        padding: 10px;
      }

      h1 {
        font-size: 1.5rem;
      }
    }

    @media screen and (min-width: 769px) {
      :root {
        --base-font-size: 16px;
        --container-width: 90%;
      }

      body {
        padding: 20px;
      }

      h1 {
        font-size: 2.5rem;
      }
    }

    h1 {
      color: #ffffff;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      margin-bottom: 20px;
      text-align: center;
    }

    #game-container {
      width: var(--container-width);
      max-width: var(--max-container-width);
      background: rgba(93, 114, 160, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      position: relative; /* For positioning the pop-up relative to the container */
    }

    canvas {
      width: 100%;
      aspect-ratio: 4 / 3;
      max-height: 70vh;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: rgb(115, 130, 185);
      border-radius: 10px;
      cursor: none;
      touch-action: none;
    }

    #game-controls {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
    }

    #game-info {
      display: flex;
      justify-content: space-around;
      width: 100%;
      font-size: 1rem;
      font-weight: bold;
      color: #ffffff;
      margin-bottom: 5px; /* Add bottom margin so it doesn't stick to the canvas */
      padding: 15px; /* Padding for better appearance */
      background: rgba(84, 112, 204, 0.3); /* Semi-transparent for integration with the game */
      border-radius: 10px; /* Rounded corners */
    }

    button {
      width: 100%;
      padding: 10px;
      font-size: 1rem;
      font-weight: bold;
      color: white;
      background: linear-gradient(135deg, #a73cff, #5e00b8);
      border: none;
      border-radius: 10px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }

    button:disabled {
      background: #4a4a5a;
      cursor: not-allowed;
      transform: translateY(0);
      box-shadow: none;
    }

    button:hover:enabled {
      background: linear-gradient(135deg, #c261ff, #7f2ad8);
      transform: translateY(-2px);
    }

    button:active:enabled {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* New CSS for pop-up */
    #popup-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7); /* Semi-transparent */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10; /* Above the canvas */
      opacity: 0;
      pointer-events: none; /* Initially not clickable */
      transition: opacity 0.3s ease;
    }

    #popup-overlay.visible {
      opacity: 1;
      pointer-events: auto; /* Clickable when visible */
    }

    #popup-content {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }

    #popup-content button {
      width: auto; /* Button is not full-width in the pop-up */
      min-width: 200px;
    }

    #game-over-message {
      color: #ffffff;
      font-size: 1.2rem;
      font-weight: bold;
      margin-bottom: 15px;
    }
  </style>
</head>
<body>
  <h1>Hit the Ethereum OS</h1>
  <div id="game-container">
    <!-- Move game-info above the canvas -->
    <div id="game-info">
      <span>Score: <span id="score">0</span></span>
      <span>Time: <span id="timer">30</span></span>
      <span>High Score: <span id="high-score">0</span></span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <!-- New pop-up overlay (remove #game-controls, move the button here) -->
    <div id="popup-overlay">
      <div id="popup-content">
        <button id="start-game-btn" disabled>Start Game</button>
      </div>
    </div>
  </div>

  <!-- Sound -->
  <audio id="hitSound" preload="auto">
    <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" />
  </audio>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startGameBtn = document.getElementById('start-game-btn');
    const scoreDisplay = document.getElementById('score');
    const timerDisplay = document.getElementById('timer');
    const highScoreDisplay = document.getElementById('high-score');
    const hitSound = document.getElementById('hitSound');
    const popupOverlay = document.getElementById('popup-overlay'); // New pop-up element
    const popupContent = document.getElementById('popup-content');

    const container = document.getElementById('game-container');
    let gameWidth, gameHeight;

    // Device detection
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }

    // Control configuration based on device
    function setupControls() {
      const isMobile = isMobileDevice();

      if (isMobile) {
        // Disable zoom
        const metaViewport = document.querySelector('meta[name="viewport"]');
        if (!metaViewport) {
          const meta = document.createElement('meta');
          meta.name = 'viewport';
          meta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
          document.head.appendChild(meta);
        }

        // Mobile-specific event listener
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Disable scroll
        document.body.style.overflow = 'hidden';
      } else {
        // Event listener for desktop
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
      }
    }

    // Handler for mobile touch
    function handleTouchStart(e) {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];

      // Convert touch coordinates to canvas coordinates
      const x = (touch.clientX - rect.left) / (rect.right - rect.left) * canvas.width;
      const y = (touch.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;

      mouseX = x;
      mouseY = y;
      hammerHit = true;

      checkHit({
        clientX: touch.clientX,
        clientY: touch.clientY
      });
    }

    function handleTouchMove(e) {
      e.preventDefault();
      if (e.touches.length > 0) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];

        mouseX = (touch.clientX - rect.left) / (rect.right - rect.left) * canvas.width;
        mouseY = (touch.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;
      }
    }

    function handleTouchEnd() {
      hammerHit = false;
    }

    // Handler for desktop mouse
    function handleMouseMove(e) {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) / (rect.right - rect.left) * canvas.width;
      mouseY = (e.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;
    }

    function handleMouseDown(e) {
      hammerHit = true;
      checkHit(e);
    }

    function handleMouseUp() {
      hammerHit = false;
    }

    // Responsive canvas resize
    function resizeCanvas() {
      gameWidth = container.clientWidth - 40;
      gameHeight = gameWidth * 0.75;
      canvas.width = gameWidth;
      canvas.height = gameHeight;
      draw();
    }

    // Call control setup and resize when the document is ready
    document.addEventListener('DOMContentLoaded', () => {
      setupControls();
      resizeCanvas();

      // Add resize event listener
      window.addEventListener('resize', resizeCanvas);
      window.addEventListener('orientationchange', resizeCanvas);
    });

    let score = 0;
    let highScore = +localStorage.getItem('ethereumOSHighScore') || 0;
    let gameTimeLeft = 30; // Changed to 30 seconds
    let gameRunning = false;
    let targets = [];
    let particles = [];
    let lastTargetSpawn = 0;
    const spawnInterval = 700;
    let lastTime = 0;
    let message = "Loading Assets...";
    const targetSize = 80;
    let mouseX = 0;
    let mouseY = 0;
    let hammerHit = false;

    // Variable for special messages
    let specialMessage = null;
    let specialMessageTimer = 0;

    // New Hole Positions (3-2-3)
    const holePositions = [
      { x: 180, y: 75 }, { x: 400, y: 75 }, { x: 620, y: 75 },
      { x: 280, y: 235 }, { x: 520, y: 235 },
      { x: 180, y: 390 }, { x: 400, y: 390 }, { x: 620, y: 390 }
    ];

    // images
    const ethOSLogo = new Image();
    ethOSLogo.src = 'photo_6030520145765582592_c.png';
    const holeImage = new Image();
    holeImage.src = createHoleSVG();
    const hammerImage = new Image();
    hammerImage.src = '1efe1d23e010ac80d4d4fd5cbbd5e60e.png';

    let imagesLoadedCount = 0;
    const totalImages = 3;

    function checkImagesLoaded() {
      imagesLoadedCount++;
      if (imagesLoadedCount === totalImages) {
        message = ""; // Clear the loading message
        startGameBtn.disabled = false;
        popupOverlay.classList.add('visible'); // Show the pop-up after assets are loaded
        resizeCanvas();
      }
    }

    ethOSLogo.onload = checkImagesLoaded;
    ethOSLogo.onerror = () => {
      ethOSLogo.src = 'https://placehold.co/80x80/2980b9/ffffff?text=OS';
      checkImagesLoaded();
    };
    holeImage.onload = checkImagesLoaded;
    hammerImage.onload = checkImagesLoaded;

    resizeCanvas();

    function updateHighScoreDisplay() {
      highScoreDisplay.textContent = highScore;
    }
    updateHighScoreDisplay();

    class Target {
      constructor(position) {
        this.x = position.x;
        this.y = position.y;
        this.width = targetSize;
        this.height = targetSize;
        this.timeToLive = 1500;
        this.hit = false;
        this.scale = 0;
        this.isExiting = false;
        this.exitScale = 1.2;
        this.exitX = 0;
        this.exitY = 0;
      }

      update(deltaTime) {
        // overshoot pop-up
        if (this.scale < 1 && !this.isExiting) {
          this.scale = Math.min(1, this.scale + deltaTime / 350);
        }

        // exit animation
        if (this.isExiting) {
          const exitDuration = 500;
          const progress = Math.min(1, deltaTime / exitDuration);
          this.x = this.exitX + (this.x - this.exitX) * (1 - progress);
          this.y = this.exitY + (this.y - this.exitY) * (1 - progress);
          this.scale = this.exitScale * (1 - progress);
        }
      }

      draw() {
        if (this.hit) return;
        const scaledSize = targetSize * this.scale;
        const xOffset = (targetSize - scaledSize) / 2;
        const yOffset = (targetSize - scaledSize) / 2;
        if (ethOSLogo.complete && ethOSLogo.naturalWidth !== 0) {
          ctx.drawImage(ethOSLogo, this.x + xOffset, this.y + yOffset, scaledSize, scaledSize);
        }
      }
    }

    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 5 + 2;
        this.color = `hsl(${Math.random() * 40 + 240}, 100%, 65%)`; // purple-blue-cyan
        this.velocity = {
          x: (Math.random() - 0.5) * 5,
          y: (Math.random() - 0.5) * 5
        };
        this.timeToLive = 1000;
      }

      update(deltaTime) {
        this.x += this.velocity.x * (deltaTime / 16.67);
        this.y += this.velocity.y * (deltaTime / 16.67);
        this.timeToLive -= deltaTime;
      }

      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // holes
      if (holeImage.complete && holeImage.naturalWidth !== 0) {
        holePositions.forEach(hole => {
          ctx.drawImage(holeImage, hole.x - 10, hole.y + targetSize - 20, 100, 50);
        });
      }

      targets.forEach(target => target.draw());
      particles.forEach(particle => particle.draw());

      // hammer
      const hammerSize = 80;
      let scale = hammerHit ? 0.9 : 1;
      let rot = hammerHit ? -10 * Math.PI / 180 : 0;

      if (hammerImage.complete && hammerImage.naturalWidth !== 0) {
        ctx.save();
        ctx.translate(mouseX, mouseY);
        ctx.rotate(rot);
        ctx.scale(scale, scale);
        ctx.drawImage(hammerImage, -hammerSize / 2, -hammerSize / 2, hammerSize, hammerSize);
        ctx.restore();
      }

      // Rendering special messages
      if (specialMessage) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = 'bold 24px Inter';
        ctx.textAlign = 'center';
        ctx.fillText(specialMessage.text, specialMessage.x, specialMessage.y);
      }

      if (!gameRunning) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 36px Inter';
        ctx.textAlign = 'center';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 5;
        ctx.fillText(message, canvas.width / 2, canvas.height / 2);
        ctx.shadowBlur = 0;
      }
    }

    function update(deltaTime) {
      if (!gameRunning) return;

      // Reduce special message timer
      if (specialMessageTimer > 0) {
        specialMessageTimer -= deltaTime;
        if (specialMessageTimer <= 0) {
          specialMessage = null;
        }
      }

      gameTimeLeft -= deltaTime / 1000;
      timerDisplay.textContent = Math.max(0, Math.floor(gameTimeLeft));

      if (gameTimeLeft <= 0) {
        endGame();
        return;
      }

      targets.forEach(target => target.update(deltaTime));
      targets = targets.filter(target => {
        target.timeToLive -= deltaTime;
        return target.timeToLive > 0 && !target.hit;
      });

      particles.forEach(particle => particle.update(deltaTime));
      particles = particles.filter(particle => particle.timeToLive > 0);

      if (Date.now() - lastTargetSpawn > spawnInterval) {
        spawnTarget();
        lastTargetSpawn = Date.now();
      }
    }

    function gameLoop(currentTime) {
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;
      update(deltaTime);
      draw();

      if (gameRunning) {
        requestAnimationFrame(gameLoop);
      }
    }

    function startGame() {
      if (gameRunning || imagesLoadedCount < totalImages) return;

      // Reset pop-up to initial state: clear all game over messages
      const existingMessages = popupContent.querySelectorAll('#game-over-message');
      existingMessages.forEach(msg => msg.remove()); // Remove any duplicate or existing messages
      startGameBtn.textContent = 'Start Game'; // Reset button text

      popupOverlay.classList.remove('visible'); // Hide the pop-up

      score = 0;
      gameTimeLeft = 30; // Changed to 30 seconds
      gameRunning = true;
      targets = [];
      particles = [];
      scoreDisplay.textContent = score;
      timerDisplay.textContent = Math.floor(gameTimeLeft);
      startGameBtn.disabled = true;

      lastTargetSpawn = Date.now();
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function endGame() {
      gameRunning = false;
      startGameBtn.disabled = false;

      // reload high-score from localStorage (so it's synchronized between tabs)
      const currentStored = +localStorage.getItem('ethereumOSHighScore') || 0;
      highScore = Math.max(score, currentStored);
      localStorage.setItem('ethereumOSHighScore', highScore);
      updateHighScoreDisplay();

      if (score > currentStored) {
        message = `New High Score: ${score}`;
      } else {
        message = `Game Over! Your Score: ${score}`;
      }

      // Clear any existing game over messages to prevent duplication
      const existingMessages = popupContent.querySelectorAll('#game-over-message');
      existingMessages.forEach(msg => msg.remove());

      // Add single game over message to pop-up
      const gameOverMessage = document.createElement('p');
      gameOverMessage.id = 'game-over-message';
      gameOverMessage.textContent = message;
      popupContent.insertBefore(gameOverMessage, startGameBtn);

      // Change button text to "Play Again"
      startGameBtn.textContent = 'Play Again';

      //popupOverlay.classList.add('visible'); // Show the pop-up again after the game is over

      draw();
    }

    function spawnTarget() {
      const availableHoles = holePositions.filter(hole => {
        return !targets.some(target => target.x === hole.x && target.y === hole.y);
      });
      if (availableHoles.length > 0) {
        const randomHole = availableHoles[Math.floor(Math.random() * availableHoles.length)];
        targets.push(new Target(randomHole));
      }
    }

    function checkHit(event) {
      if (!gameRunning) return;

      const rect = canvas.getBoundingClientRect();
      const clientX = event.clientX || (event.touches[0] ? event.touches[0].clientX : 0);
      const clientY = event.clientY || (event.touches[0] ? event.touches[0].clientY : 0);
      const x = (clientX - rect.left) / (rect.right - rect.left) * canvas.width;
      const y = (clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;

      for (let i = 0; i < targets.length; i++) {
        const target = targets[i];
        if (x > target.x && x < target.x + target.width && y > target.y && y < target.y + target.height) {
          score++;
          scoreDisplay.textContent = score;
          target.hit = true;
          target.isExiting = true;
          target.exitX = x;
          target.exitY = y;
          setTimeout(() => {
            targets.splice(i, 1);
          }, 200);

          // Add a special message right at the clicked target location
          specialMessage = {
            text: "when code sir?",
            x: x,
            y: y
          };
          specialMessageTimer = 1000; // Show for 1 second

          // sound
          hitSound.currentTime = 0;
          hitSound.play().catch(() => {});

          // particle
          for (let j = 0; j < 10; j++) {
            particles.push(new Particle(x, y));
          }
          return;
        }
      }
    }

    startGameBtn.addEventListener('click', startGame);
    // disable context menu
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    // helper SVG
    function createHoleSVG() {
      const svg = `
        <svg width="100" height="50" xmlns="http://www.w3.org/2000/svg">
          <ellipse cx="50" cy="25" rx="50" ry="25" fill="#111827"/>
          <ellipse cx="50" cy="25" rx="40" ry="20" fill="#374151"/>
        </svg>
      `;
      return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
    }

    function createHammerSVG() {
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
          <path fill="#d1d5db" d="M502.6 117.3l-107.9-107.9c-12.5-12.5-32.8-12.5-45.3 0l-107.9 107.9c-12.5 12.5-12.5 32.8 0 45.3l107.9 107.9c12.5 12.5 32.8 12.5 45.3 0l107.9-107.9c12.5-12.5 12.5-32.8 0-45.3z"/>
          <path fill="#9ca3af" d="M283.3 283.3L117.3 117.3c-12.5-12.5-32.8-12.5-45.3 0L28.7 166.7c-12.5 12.5-12.5 32.8 0 45.3L166.7 350c12.5 12.5 32.8 12.5 45.3 0l49.3-49.3c12.5-12.5 12.5-32.8 0-45.3z"/>
        </svg>
      `;
      return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
    }
  </script>
</body>
</html>
